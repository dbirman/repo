# ggplot Intro

### Dan Birman
### 10/14/14, edited 12/23/14

This was a tutorial that I put together for the first year psych students in fall quarter 2014. Enjoy!

# ggplot

Let's load the `ggplot2` package, which we will use for complex graphing. ggplot includes a sample dataset called "diamonds" which we will also use.

```{r}
library(ggplot2)
```

Diamonds is quite large, so let's reduce the size to make graphing a bit faster.

```{r}
diamonds_sml = diamonds[sample(nrow(diamonds), 1000), ]
str(diamonds_sml)
```

As you can see, `diamonds_sml` includes a number of useful parameters. The carat (a measure of value), cut (a measure of quality), color and clarity (measures of purity), and the price of a variety of diamonds.

Let's take a look at the `diamonds_sml` dataset through plots. We are going to use `ggplot` to do this, so a quick introduction to what we're doing:

What is a ggplot? In general, a ggplot is an "object" which can hold data, aesthetics, and layers.

 - Data: Any data.frame object you generated, for example, `diamonds_sml`
 - Aesthetics: A mapping of data, for example a variable that goes on the x axis and a variable that goes on the y axis. Aesthetics can also "group" objects, or "differentiate" objects, we will see examples of this.
 - Layers: Actual plots, for example a "boxplot" layer, or a "scatterplot" layer.
 
To initialize a ggplot object you use:
```{r}
g = ggplot()
```

This object `g` has no data, aesthetics, or layers. Note that R knows it can't do anything with `g` because it lacks data, aesthetics, and layers. If we tried to call "g", R would complain. Let's re-initialize `g` with data:

```{r}
g = ggplot(data=diamonds_sml)
```

Now `g` has access to the data in `diamonds_sml`, this is similar to calling "attach(diamonds_sml)"

Let's look first at how carat influences price, to do this we need to add an "aesthetic" which will map carat to the X axis and price to the Y axis. 

```{r}
g = ggplot(data=diamonds_sml,aes(x=carat,y=cut))
```

*Note*: that we don't say "aes=". ggplot understands that this is the aesthetic object.

Now we need to consider how we want to visualize the data. One logical way would be to start with a scatterplot. In ggplot a scatterplot is added by using "geom_point".

```{r}
ggplot(data=diamonds_sml,aes(x=carat,y=price)) +
  geom_point()
```

*Note*: Previously I saved the ggplot object into "g". You could then plot it by calling "g" directly, but to save a line of code we can just let R plot the graph directly on return.

Interesting. It looks like carat predicts price. Maybe we want to add a linear regression line, ggplot allows to do this very simply with an additional layer. The new layer is "geom_smooth", which adds a smoothed line. We can set the "method" argument of geom_smooth to specify what kind of smoothing. In this case we will use "lm" to invoke the linear model. Explore the different options on your own time!

```{r}
ggplot(data=diamonds_sml,aes(x=carat,y=price)) +
  geom_point() +
  geom_smooth(method="lm") +
  theme_bw()
```

*Note*: I added "theme_bw()" to remove the gray background, which some people absolutely hate. Other themes also exist and you can create your own as well.

That's it for the basics! Everything else is bonus. Here are some additional considerations:

### Grouping

ggplot can separate data automatically into groups according to variables in your dataframe. For example we might be interested in whether there is an interaction between cut and carat in their influence on price. To look at this graphically we can take the previous plot and "group" the points by cut.

```{r}
ggplot(data=diamonds_sml,aes(x=carat,y=price,color=cut)) +
  geom_point()
```

*Note*: I used "color" to group the data, but you might also use "group", "fill", or other variables. Check the aesthetics help to get more detail.

This plot isn't very understandable, plotting the regression lines for each group alone might be more understandable.

```{r}
ggplot(data=diamonds,aes(x=carat,y=price,color=cut)) +
  geom_point() +
  geom_smooth(method="lm")
```

You may want to zoom in to see this graph clearly, but it does seem to show a hint of an interaction (i.e. the slope of the lines differ, so the effect of carat on price at different levels of cut is not always the same). Specifically, there are two groups of carat->price effects. Diamonds with the "fair" cut seem to increase in price much more slowly than all of the other diamonds, although there is still variability between the other diamonds amongst themselves.

**A side note for Ewart/etc**: *This is really the value of graphical visualization to me and why I am pushing this point so much. It takes seconds to see the interaction in this graph. Through lm() alone it's still obvious:*

```{r}
summary(lm(price~as.numeric(cut)*carat,diamonds_sml))
```

*But, as we discussed in the letter, it doesn't tell you the whole picture. You wouldn't know there were two clusters of slopes if you ran only the lm() above although you would realize that there was an interaction. ggplot gives you the power to do this kind of analysis at a very high speed and in an efficient manner.*

### Inheriting data and aesthetics

Each ggplot layer "inherits" the data and aesthetics of the base plot. But you can also specify these directly at each layer. Let's look at the previous plot, but now we will plot only the main regression line.

```{r}
ggplot() +
  geom_point(data=diamonds_sml,aes(x=carat,y=price,color=cut)) +
  geom_smooth(data=diamonds_sml,aes(x=carat,y=price),method="lm")
```

Now, the layers each have their aesthetic specified individually. One layer, the "points" still has the data split by cut. On the other hand, since we saw no interaction before there is no reason to split the regression line by group.

### Text

Let's keep adding layers! *Note*: I'm using some shorthand here, for example omitting "data=", look carefully and you should be able to parse what's happening.

```{r}
ggplot(data=diamonds_sml,aes(carat,price,color=cut)) +
  geom_point() +
  geom_smooth(method="lm",color="black") +
  ggtitle("Carat vs. Price")
```

### Facets

Previously we used "cut" to color different diamond groups, to see the effect of carat on price at different levels of cut. Another way to look at this is to separate the data into individual plots for each example.

```{r}
ggplot(data=diamonds_sml,aes(carat,price)) +
  geom_point() +
  geom_smooth(method="lm",color="black") +
  facet_grid(.~cut) +
  ggtitle("Carat vs. Price")
```

The dimensions on facet_grid determine how the plot will be set up. Try using "cut~." or "cut~clarity" for other examples.

In the end, that plot isn't very pretty though. Part of ggplot's power is that you can "layer" settings on top of each other. By adding a color grouping we can improve the elegance of this graph considerably.

```{r}
ggplot(data=diamonds_sml,aes(carat,price,color=cut)) +
  geom_point() +
  geom_smooth(method="lm",color="black") +
  facet_grid(.~cut) +
  ggtitle("Carat vs. Price")
```

Now the graph has some redundant information, but it's also easy to see what's happening. We could easily remove the legend as well:

```{r}
ggplot(data=diamonds_sml,aes(carat,price,color=cut)) +
  geom_point() +
  geom_smooth(method="lm",color="black") +
  facet_grid(.~cut) +
  ggtitle("Carat vs. Price") +
  guides(color=F)
```

*Note*: Why "color=F"? What if we used a different grouping type?

# Other packages

There are a lot of other R graphing resources. Some of the packages that you may want to explore include:

**semPlot**

(Loading Data in Background)
```{r, echo=FALSE}
```


```{r}
library(semPlot)
# an example here, but I don't have one at the moment
```

**GGally**

```{r}
library(GGally)
ggpairs(diamonds_sml,c(1,2,3,7))
```

**Effects**

```{r}
library(effects)
rs1 = lm(price ~ carat + cut + clarity,diamonds_sml)
plot(allEffects(rs1))
```

*Note*: You need to be careful using this package, what exactly is being plotted? If you can answer that question you will have understood much of the class...

**Normal Distributions**

```{r}
n = 100
sigma = 2
se = sigma/sqrt(n)
x = seq(3,5.3,.01)
d0 = dnorm(x,mean=4.0,sd=se)
d1 = dnorm(x,mean=4.4,sd=se)
dat = data.frame(null=d0,alt=d1,x=x)
val_0 = qnorm(.05,mean=4.0,sd=se,lower.tail=F)
ggplot() + 
  geom_line(data=dat,aes(x,null,color="red")) +
  geom_line(data=dat,aes(x,alt,color="green")) +
  xlab("Values") + ylab("Density") +
  geom_vline(xintercept=val_0,color="blue") +
  geom_ribbon(aes(x=dat$x[dat$x>val_0],ymin=0,ymax=dat$null[dat$x>val_0]),alpha=0.2,fill="darkred") +
  geom_ribbon(aes(x=dat$x[dat$x>val_0],ymin=0,ymax=dat$alt[dat$x>val_0]),alpha=0.2,fill="51") +
  scale_color_manual(name="Hypothesis",values=c("red"="red","green"="green"),labels=c("Alternative","Null"))
```

**plyr**

```{r}
library(plyr)

meanValues = ddply(diamonds_sml,c("cut"),summarise,mu=mean(price))

ggplot(data=diamonds_sml,aes(carat,price,color=cut)) +
  geom_point() +
  geom_smooth(method="lm") +
  geom_jitter(position=position_jitter(width=3,height=3)) +
  geom_text(data=meanValues,aes(label=round(meanValues$mu,2),x=1,y=20000)) +
  geom_hline(data=meanValues,aes(yintercept=mu)) +
  facet_grid(.~cut) + 
  guides(color=F)
```

*Note*: You may need to zoom in. Faceting in ggplot is smart enough to get the correct mean values (stored in meanValues$mu) for each of the facets individually. This kind of graph really shows off the elegance and simplicity of the ggplot package!